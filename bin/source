#!/usr/bin/env bash

set -exuo pipefail
shopt -s nullglob

auto_decompress() (
	case "${1##*.}" in
		gz)
			gzip -d < "$1"
			;;
		xz)
			xz -d < "$1"
			;;
		bz2)
			bzip2 -d < "$1"
			;;
		*)
			exit 1
			;;
	esac
)


# Usage:
# apt_src [--ignore-orig] <package_name>[=<version>]
#
# Downloads and extracts the source files of a Debian package.
# - With <package_name>=<version>, fetches the specific version.
# - With --ignore-orig, skips processing the original source archive (*.orig.tar.*).
# If no version is provided, it downloads the candidate version.
apt_src() (
	ignore_orig=false
	if [ "$1" = "--ignore-orig" ]; then
		ignore_orig=true
		shift
	fi

	tmp_dir="$(mktemp -d)"
	trap 'cd / && rm -rf "$tmp_dir"' EXIT
	cd "$tmp_dir"

	# if the src repo provides multiple sources for the same package
	# download the src with the same version as the candidate
	if [[ "$1" = *=* ]]; then
		# specific version requested, do nothing
		pkg="$1"
	else
		# source package name might not have any installable candidates, so check the candidate version via one of the provided packages
		candidate=""
		for p in $(apt-cache showsrc "$1" | grep Binary | sed 's/Binary: //' | tr -d "," | tr '[:blank:]' '\n' | sort | uniq | grep -v -- -udeb); do
			if candidate=$(apt-cache policy "$p"); then
				candidate=$(apt-cache policy "$p" | grep Candidate | cut -d: -f 2- | tr -d "[:blank:]" | sed 's/+b[0-9]\+$//')
				break
			fi
		done
		if [[ "$candidate" = "" ]]; then
			echo "cannot determine candidate version"
			exit 1
		fi
		pkg="${1}=${candidate}"
	fi

	apt-get source --only-source --download-only "$pkg"

	orig=(*.orig.tar.*)
	if [ -n "${orig[*]}" ]; then
		[ "$ignore_orig" = true ] || auto_decompress "$orig" | tee "$dir/orig.tar" | tar --extract --strip-components 1 --directory "$dir/src"
		rm "${orig[@]}"
	fi

	diff=(*.debian.tar.*)
	if [ -n "${diff[*]}" ]; then
		auto_decompress "$diff" | tar --extract --directory "$dir/src"
		rm "${diff[@]}"
	else
		native=(*.tar.*)
		auto_decompress "$native" | tar --extract --strip-components 1 --directory "$dir/src"
		rm "${native[@]}"
	fi
)

git_src() (
	tmp_dir="$(mktemp -d)"
	trap 'cd / && rm -rf "$tmp_dir"' EXIT
	git clone --depth 1 --recurse-submodules "$@" "$tmp_dir/src"
	mkdir "$tmp_dir/_"
	git -C "$tmp_dir/src" ls-files --recurse-submodules -z | tar --directory "$tmp_dir/src" --create --null --files-from - | tar --extract --directory "$tmp_dir/_"
	tar --create --directory "$tmp_dir" _ | tee "$dir/orig.tar" | tar --extract --strip-components 1 --directory "$dir/src"
)

git_src_commit() (
	tmp_dir="$(mktemp -d)"
	trap 'cd / && rm -rf "$tmp_dir"' EXIT
	commit="$1"
	repo="$2"

	mkdir "$tmp_dir/src"
	git -C "$tmp_dir/src" init
	git -C "$tmp_dir/src" remote add origin "$repo"
	git -C "$tmp_dir/src" fetch --depth 1 origin "$commit"
	git -C "$tmp_dir/src" checkout FETCH_HEAD
	git -C "$tmp_dir/src" submodule update --init --recursive --depth 1

	mkdir "$tmp_dir/_"
	git -C "$tmp_dir/src" ls-files --recurse-submodules -z | tar --directory "$tmp_dir/src" --create --null --files-from - | tar --extract --directory "$tmp_dir/_"
	tar --create --directory "$tmp_dir" _ | tee "$dir/orig.tar" | tar --extract --strip-components 1 --directory "$dir/src"
)

import_src() (
	cp -r "$1/." "$dir/src/."
)

apply_patches() (
	patch_dir="${1-patches}"
	if [ -f "$patch_dir/series" ]; then
		if [[ -s "$patch_dir/series" && "$(tail -c 1 "$patch_dir/series" | wc -l)" != 1 ]]; then
			echo "series file must end with a newline" >&2
			exit 1
		fi
		while read -r patch; do
			(cd "$dir/src" && patch -p1;) < "$patch_dir/$patch"
		done < "$patch_dir/series"
	fi
)

import_upstream_patches() (
	patch_dir="${1-upstream_patches}"
	if [ -f "$patch_dir/series" ]; then
		if [[ -s "$patch_dir/series" && "$(tail -c 1 "$patch_dir/series" | wc -l)" != 1 ]]; then
			echo "series file must end with a newline" >&2
			exit 1
		fi
		while read -r patch; do
			if [ -e "$dir/src/debian/patches/$patch" ]; then
				echo "patch $patch already exists in debian/patches" >&2
				exit 1
			fi

			mkdir -p "$(dirname "$dir/src/debian/patches/$patch")"
			cp "$patch_dir/$patch" "$dir/src/debian/patches/$patch"
			echo "$patch" >>"$dir/src/debian/patches/series"
		done <"$patch_dir/series"
	fi
)

# Usage:
# pkg_version_in_gl_version <package_name> <version> <start_version> [max_versions] [base_url]
#
# Searches for a snapshot by searching through Garden Linux versions (e.g., 1882.0, 1881.0, etc.).
# - <package_name>: The source package name to search for
# - <version>: The exact version to find (e.g., "3.8.9-3")
# - <start_version>: Starting GL version to search from (e.g., "1882")
# - [max_versions]: Maximum number of versions to search forwards (default: 30)
# - [base_url]: Optional base URL (defaults to https://packages.gardenlinux.io)
# Returns the "gl:$version" if found, or exits with error if not found.
pkg_version_in_gl_version() (
	pkg="$1"
	version="$2"
	start_version="$3"
	max_versions="${4:-30}"
	base_url="${5:-https://packages.gardenlinux.io}"

	tmp_dir="$(mktemp -d)"
	trap 'cd / && rm -rf "$tmp_dir"' EXIT

	command -v curl >/dev/null || apt-get install --no-install-recommends -y curl >&2
	command -v gunzip >/dev/null || apt-get install --no-install-recommends -y gzip >&2

	echo "Searching for package '$pkg' version '$version' starting from GL version $start_version..." >&2

	major=$(echo "$start_version" | cut -d. -f1)
	minor=0

	versions_checked=0
	while [ "$versions_checked" -lt "$max_versions" ]; do
		current_version="${major}.${minor}"
		sources_url="${base_url}/gardenlinux/dists/${current_version}/main/source/Sources.gz"
		echo "Checking GL version $current_version at $sources_url..." >&2

		if curl -sSLf "$sources_url" -o "${tmp_dir}/sources_${current_version}.gz" 2>/dev/null; then
			echo "Found GL version $current_version, checking for package..." >&2

			if gunzip -c "${tmp_dir}/sources_${current_version}.gz" >"${tmp_dir}/sources_${current_version}.txt" 2>/dev/null; then
				if grep -q "^Package: $pkg$" "${tmp_dir}/sources_${current_version}.txt"; then
					pkg_version=$(awk -v pkg="$pkg" '
						/^Package: / { if ($2 == pkg) { in_package = 1; next } else { in_package = 0; next } }
						in_package && /^Version: / { print $2; exit }
					' "${tmp_dir}/sources_${current_version}.txt")
					if [ -n "$pkg_version" ]; then
						echo "GL version $current_version has package '$pkg' version '$pkg_version'" >&2

						if [ "$pkg_version" = "$version" ]; then
							echo "âœ“ MATCH: Found GL version $current_version with package '$pkg' version '$version'" >&2
							rm -f "${tmp_dir}/sources_${current_version}.gz" "${tmp_dir}/sources_${current_version}.txt"
							echo "gl:${current_version}"
							return 0
						fi
					else
						echo "GL version $current_version has package '$pkg' but could not determine version" >&2
					fi
				else
					echo "GL version $current_version does not contain package '$pkg'" >&2
				fi

				rm -f "${tmp_dir}/sources_${current_version}.txt"
			else
				echo "ERROR: Failed to decompress Sources file for GL version $current_version" >&2
			fi

			rm -f "${tmp_dir}/sources_${current_version}.gz"
		else
			echo "GL version $current_version not found or not accessible" >&2
		fi

		major=$((major + 1))

		versions_checked=$((versions_checked + 1))
	done

	echo "Error: No snapshot found containing package '$pkg' version '$version' in the last $max_versions GL versions from $start_version" >&2
	exit 1
)

# Usage:
# snapshot_src <package_name> <snapshot> [base_url]
#
# Downloads and extracts source files from a Garden Linux snapshot repository.
# - <package_name>: The source package name to download
# - <snapshot>: The snapshot timestamp or GL version to use (e.g. "1754597610" or "gl:1982")
# - [base_url]: Optional base URL (defaults to https://packages.gardenlinux.io)
snapshot_src() (
	pkg="$1"
	snapshot="$2"
	base_url="${3:-https://packages.gardenlinux.io}"

	command -v curl >/dev/null || apt-get install --no-install-recommends -y curl >&2
	command -v gunzip >/dev/null || apt-get install --no-install-recommends -y gzip >&2
	command -v xz >/dev/null || apt-get install --no-install-recommends -y xz-utils >&2

	# Check if this is a GL version (format: gl:XXXX.X)
	if [[ "$snapshot" =~ ^gl: ]]; then
		gl_version="${snapshot#gl:}"
		sources_url="${base_url}/gardenlinux/dists/${gl_version}/main/source/Sources.gz"
		echo "Using GL version $gl_version" >&2
	else
		# Regular timestamp-based snapshot
		sources_url="${base_url}/debian-snapshot/dists/${snapshot}/main/source/Sources.gz"
		echo "Using snapshot timestamp $snapshot" >&2
	fi
	if ! curl -sSLf "$sources_url" | gunzip >Sources; then
		echo "Error: Failed to download Sources file from $sources_url" >&2
		exit 1
	fi

	package_section=$(awk -v pkg="$pkg" '
		/^Package: / {
			if ($2 == pkg) {
				in_package = 1;
				next
			} else {
				in_package = 0;
				next
			}
		}
		in_package && /^$/ && package_started {
			exit
		}
		in_package {
			package_started = 1;
			print
		}
	' Sources)

	if [ -z "$package_section" ]; then
		echo "Error: Package '$pkg' not found in snapshot" >&2
		exit 1
	fi

	directory=$(echo "$package_section" | grep "^Directory:" | cut -d' ' -f2)

	if [ -z "$directory" ]; then
		echo "Error: Directory not found for package '$pkg'" >&2
		exit 1
	fi

	# Extract the list of source files from the package section
	files_list=$(echo "$package_section" | awk '
		/^Files:/ {in_files=1; next}
		in_files && /^[^ ]/ {exit}
		in_files && /^ / {print $3}
	')
	# Filter for .orig and .debian tarballs, ignore .asc signatures, and ensure uniqueness.
	files=$(echo "$files_list" | grep -F "${pkg}_" | grep -E '\.(orig|debian)\.tar\.' | grep -v '\.asc$' | sort -u)

	if [ -z "$files" ]; then
		echo "Error: No source files found for package '$pkg'" >&2
		exit 1
	fi

	mkdir -p "$dir/src"

	for file in $files; do
		# Check if this is a GL version to use the correct URL structure
		if [[ "$snapshot" =~ ^gl: ]]; then
			file_url="${base_url}/gardenlinux/${directory}/${file}"
		else
			file_url="${base_url}/${directory}/${file}"
		fi
		case "$file" in
		*.orig.tar.* | *.debian.tar.*)
			case "$file" in
			*.xz) decompressor="xz -d" ;;
			*.gz) decompressor="gzip -d" ;;
			*.bz2) decompressor="bzip2 -d" ;;
			esac
			tar_opts="--directory \"$dir/src\""
			# Only strip components for orig tarballs
			[[ "$file" == *.orig.tar.* ]] && tar_opts="--strip-components 1 $tar_opts"

			if [[ "$file" == *.orig.tar.* ]]; then
				# For orig files, save to orig.tar and extract
				if ! curl -Lf "$file_url" | $decompressor | tee "$dir/orig.tar" | eval tar xf - $tar_opts; then
					echo "Error: Failed to download/extract $file" >&2
					exit 1
				fi
			else
				# For debian files, just extract
				if ! curl -Lf "$file_url" | $decompressor | eval tar xf - $tar_opts; then
					echo "Error: Failed to download/extract $file" >&2
					exit 1
				fi
			fi
			;;
		esac
	done
)

handle_leave_artifacts_exit() (
	output_run_dir="$output/run_$(date -u +"%Y-%m-%dT%H-%M-%SZ")"
	cd /
	mv "$dir" $output_run_dir
	mv $output_run_dir/src $output_run_dir/a
	cp -r $output_run_dir/a $output_run_dir/b
)

email="contact@gardenlinux.io"
maintainer="Garden Linux Builder"
distribution=gardenlinux
message="Rebuild for Garden Linux."
version=
version_suffix=gl~dev


dir="$(mktemp -d)"
output="$(pwd)/output"
if [ "$leave_artifacts" = "true" ]; then
  trap handle_leave_artifacts_exit EXIT
else
  trap 'cd / && rm -rf "$dir"' EXIT
fi

mkdir "$dir/src"

. prepare_source

[ -n "$version" ] || version="$(cd "$dir/src" && dpkg-parsechangelog --show-field Version)"

if [ -e "$dir/src/debian/changelog" ]; then
	(cd "$dir/src" && DEBEMAIL="$email" DEBFULLNAME="$maintainer" dch --newversion "$version$version_suffix" --distribution "$distribution" --force-distribution -- "$message";)
else
	(cd "$dir/src" && DEBEMAIL="$email" DEBFULLNAME="$maintainer" dch --create --package "$pkg" --newversion "$version$version_suffix" --distribution "$distribution" -- "$message";)
fi

pkg="$(cd "$dir/src" && dpkg-parsechangelog --show-field Source)"
version="$(cd "$dir/src" && dpkg-parsechangelog --show-field Version)"
version_orig="${version%-*}"

if [ "$version" != "$version_orig" ]; then
	xz < "$dir/orig.tar" > "$dir/${pkg}_${version_orig#*:}.orig.tar.xz"
fi
if [ -e "$dir/orig.tar" ]; then
	rm "$dir/orig.tar"
fi

if [ -f finalize_source ]; then
	. finalize_source
fi

chown -R user:users "$dir"
(
	cd "$dir/src"
	su -s /bin/sh -c 'dpkg-source --build .' user
)

# all artifacts including src folder are in output/run_<data-time> folder in case of leave_artifacts (see EXIT trap)
if [ "$leave_artifacts" != "true" ]; then
  rm -rf "$dir/src"
  mkdir -p .build
  cp -r "$dir/." .build/.
fi
